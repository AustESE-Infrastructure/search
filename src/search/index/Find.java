/*
 * This file is part of Search.
 *
 *  Search is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  Search is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with Search.  If not, see <http://www.gnu.org/licenses/>.
 *  (c) copyright Desmond Schmidt 2015
 */

package search.index;
import calliope.core.constants.Database;
import calliope.core.constants.JSONKeys;
import calliope.core.database.Connection;
import calliope.core.database.Connector;
import edu.luc.nmerge.mvd.MVD;
import edu.luc.nmerge.mvd.MVDFile;
import search.exception.SearchException;
import java.util.StringTokenizer;
import org.json.simple.JSONObject;
import org.json.simple.JSONValue;
/**
 * Find things in the indices generated by BuildIndex
 * @author desmond
 */
public class Find {
    static final int MAX_PRECIS_TOKENS = 20;
    static int HITS_PER_PAGE = 20;
    /**
    * Get the last component of the version id, its short name
    * @param vid the full version id
    * @return a simple version name
    */
    private String shortName( String vid )
    {
        int index = vid.lastIndexOf("/");
        if ( index != -1 )
            return vid.substring(index+1);
        else
            return vid;
    }
    /**
     * Get the group name or path leading tot he final short name
     * @param vid the full version id
     * @return a path delimited by slashes and ending with one or ""
     */
    private String group( String vid )
    {
        int index = vid.lastIndexOf("/");
        if ( index != -1 )
            return vid.substring(0,index+1);
        else
            return "";
    }
    /**
     * Make a short sample of the text ending in ...
     * @param text the text possibly long
     * @return a short sample of the first few words
     */
    private String sample( String text )
    {
        int nTokens = 0;
        StringBuilder sb = new StringBuilder();
        StringTokenizer st = new StringTokenizer(text," \n\t" );
        while ( st.hasMoreTokens() )
        {
            sb.append( st.nextToken() );
            sb.append(" ");
            if ( nTokens >= MAX_PRECIS_TOKENS )
                break;
            nTokens++;
        }
        sb.append(" ...");
        return sb.toString();
    }
    String digestCortex( String docid, String[] vid ) throws SearchException
    {
        try
        {
            Connection conn = Connector.getConnection();
            StringBuilder doc = new StringBuilder();
            String bson = conn.getFromDb( Database.CORTEX, docid );
            JSONObject jDoc = (JSONObject)JSONValue.parse( bson );
            String format = (String)jDoc.get(JSONKeys.FORMAT);
            String body = (String)jDoc.get(JSONKeys.BODY);
            doc.append("{ ");
            if ( format != null && format.startsWith("MVD") && vid != null 
                && vid.length>0 )
            {
                MVD mvd = MVDFile.internalise( body );
                String encoding = mvd.getEncoding();
                int version = mvd.getVersionByNameAndGroup( shortName(vid[0]), 
                    group(vid[0]) );
                if ( version != 0 )
                {
                    //byte[] data = mvd.getVersion( version );
                   // body = new String( data, encoding );
                }
            }
            body = sample( body );
            doc.append("\"digest\": \"");
            doc.append( body );
            doc.append("\"");
            if ( jDoc.containsKey(JSONKeys.TITLE) )
            {
                doc.append(", \"title\": \"");
                doc.append((String)jDoc.get(JSONKeys.TITLE) );
                doc.append("\"");
            }
            doc.append(", \"docid\": \"");
            doc.append(docid);
            doc.append("\"");
            if ( vid != null )
            {
                doc.append(", \"vids\": [ ");
                for ( int j=0;j<vid.length;j++ )
                {
                    doc.append("\"");
                    doc.append(vid[j]);
                    doc.append("\"");
                    if ( j<vid.length-1 )
                        doc.append(", ");
                }
                doc.append(" ]");
            }
            doc.append( " }");
            return doc.toString();
        }
        catch ( Exception e )
        {
            throw new SearchException( e );
        }
    }
   /**
     * Search for a query string in the index
     * @param line the query as text
     * @param language the language name of the index e.g. "english"
     * @param start the hit-number to start from
     * @return a JSON document containing the docids and vids of matching docs
     * @throws SearchException 
     */
    public String search( String line, String language, int start ) 
        throws SearchException
    {
        return null;
    }
}
